---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/nl-NL/f198e829-2dee-4ba3-9a1c-ce68d309e6cd.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Wauw, je hebt het goed gedaan en inmiddels weet je
---

## Samenvatting lijsten

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Krachtig{{1}}

- Verzameling van waarden{{2}}

- Kan verschillende typen bevatten{{3}}

- Wijzigen, toevoegen, verwijderen{{4}}

- De noodzaak van datawetenschap{{5}}

  - Wiskundige bewerkingen op verzamelingen{{6}}

  - Snelheid{{7}}

`@script`
dat de Python-lijst behoorlijk krachtig is. Een lijst kan elk type bevatten en zelfs verschillende types tegelijk. Je kunt ook elementen wijzigen, toevoegen en verwijderen. Dat is prachtig, maar er mist één ding, een functie die superbelangrijk is voor beginnende datawetenschappers zoals jij. Bij het analyseren van data wil je vaak bewerkingen uitvoeren over hele verzamelingen waarden, en je wilt dat snel doen. Met lijsten is dat een probleem.
---

## Illustratie

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Laten we de lengtes van je familie en jezelf er weer bij pakken. Stel dat je ook ieders gewicht hebt gevraagd. Niet heel netjes, maar alles voor de wetenschap, toch? Je eindigt met twee lijsten, height en weight. De eerste persoon is één-komma-drieënzeventig meter lang en weegt vijfenzestig-komma-vier kilogram.

Als je nu voor elk gezinslid de Body Mass Index wilt berekenen, hoop je dat deze aanroep werkt en de berekeningen elementgewijs uitvoert.

Helaas geeft Python een fout, omdat het geen idee heeft hoe het berekeningen op lijsten moet uitvoeren. Je zou dit kunnen oplossen door elk lijst-element één voor één langs te gaan en de BMI per persoon te berekenen, maar dat is behoorlijk inefficiënt en vermoeiend om te schrijven.
---

## Oplossing: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Numerieke Python{{1}}

- Alternatief voor Python-lijst: NumPy-array{{2}}

- Berekeningen over hele arrays{{3}}

- Makkelijk en snel{{4}}

- Installatie{{5}}

	- In de terminal: `pip3 install numpy`{{6}}

`@script`
Een veel elegantere oplossing is het gebruik van NumPy, ofwel Numeric Python. Het is een Python-pakket dat onder andere een alternatief biedt voor de gewone Python-lijst: de NumPy-array. De NumPy-array lijkt erg op de lijst, maar heeft één extra eigenschap: je kunt berekeningen uitvoeren over volledige arrays. Het is heel eenvoudig en ook nog eens supersnel.

Het NumPy-pakket is al geïnstalleerd op de servers van DataCamp, maar als je er op je eigen systeem mee wilt werken, ga dan naar de commandoregel en voer uit: pip3 install numpy.

Vervolgens,
---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
om NumPy daadwerkelijk in je Python-sessie te gebruiken, kun je het numpy-pakket importeren, zo.

Laten we beginnen met het maken van een numpy-array. Dat doe je met NumPy’s array-functie: de invoer is een gewone Python-lijst. Ik gebruik array hier twee keer om NumPy-versies te maken van de lijsten height en weight van daarnet: np_height en np_weight:

Laten we proberen om ieders BMI weer met één aanroep te berekenen.

Deze keer werkte het prima: de berekeningen werden elementgewijs uitgevoerd. De BMI van de eerste persoon werd berekend door het eerste element in np_weight te delen door het kwadraat van het eerste element in np_height, de tweede persoon met de tweede lengte- en gewichtselementen, enzovoort.
---

## Vergelijking

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Een korte vergelijking. Eerst probeerden we berekeningen te maken met gewone lijsten, maar dat gaf een fout, omdat Python niet weet hoe het zulke berekeningen met lijsten moet uitvoeren. Vervolgens zijn deze gewone lijsten geconverteerd naar NumPy-arrays. Dezelfde bewerkingen werken nu prima: NumPy kan arrays behandelen als enkele waarden, wat behoorlijk geweldig is als je het mij vraagt.
---

## NumPy: opmerkingen

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- NumPy-arrays: bevatten maar één type{{1}}

`@script`
Toch moet je goed blijven opletten. Allereerst kan NumPy dit allemaal zo makkelijk omdat het aanneemt dat je NumPy-array slechts waarden van één type kan bevatten. Het is óf een array van floats, óf een array van booleans, enzovoort. Als je toch probeert een array met verschillende types te maken, zoals hier, zal de resulterende NumPy-array één enkel type bevatten, in dit geval string. De boolean en de float zijn allebei omgezet naar strings.

Ten tweede moet je weten dat een NumPy-array gewoon een nieuw soort Python-type is, zoals de types float, string en list van daarnet. Dat betekent dat het zijn eigen methoden heeft, die anders kunnen werken dan je verwacht.
---

## NumPy: opmerkingen

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Verschillende typen: verschillend gedrag!{{3}}

`@script`
Neem bijvoorbeeld deze Python-lijst en deze numpy-array.

Als je python_list + python_list doet, worden de lijst-elementen aan elkaar geplakt, waardoor je een lijst met zes elementen krijgt. Doe je dit met de numpy-arrays, dan zal Python juist een elementgewijze som van de arrays maken.

Let dus goed op wanneer je verschillende Python-types door elkaar gebruikt, want de uitkomsten kunnen flink verschillen!

Afgezien van deze subtiliteiten,
---

## NumPy-subsets maken

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
kun je met NumPy-arrays vrijwel hetzelfde werken als met gewone Python-lijsten. Als je bijvoorbeeld elementen uit je array wilt halen, kun je vierkante haakjes gebruiken. Stel dat je de bmi voor de tweede persoon wilt, dus op index één. Dan werkt dat hiermee.

Specifiek voor NumPy is er nog een andere manier om een subset te maken: met een array van booleans. Stel dat je alle BMI-waarden in de bmi-array wilt die hoger dan drieëntwintig zijn. Een eerste stap is het groter-dan-teken gebruiken, zo:

Het resultaat is een NumPy-array met booleans: True als de bijbehorende bmi boven drieëntwintig ligt, False als die eronder ligt. Daarna kun je deze boolean-array binnen vierkante haakjes gebruiken om een subset te maken. Alleen de bmi-elementen die boven drieëntwintig liggen, dus waarvoor de bijbehorende boolean True is, worden geselecteerd. Er is maar één BMI die boven drieëntwintig ligt, dus we eindigen met een NumPy-array met één waarde, die specifieke BMI.

Een vergelijking gebruiken om een selectie van je data te maken is een heel gebruikelijke manier om verrassende inzichten te krijgen.
---

## Laten we oefenen!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Leer alles over deze en andere NumPy-basics in de oefeningen!
