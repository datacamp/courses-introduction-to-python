---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/vi-VN/74f99755-0276-4fe5-a563-c3d7932a1622.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Wow, bạn đã làm rất tốt, và đến giờ chắc hẳn bạn đã nhận ra
---

## Tổng kết về list

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Hiệu quả{{1}}

- Bộ sưu tập các giá trị{{2}}

- Chứa nhiều kiểu dữ liệu khác nhau{{3}}

- Thay đổi, thêm, xóa{{4}}

- Nhu cầu về Khoa học Dữ liệu{{5}}

  - Các phép toán trên tập hợp dữ liệu{{6}}

  - Tốc độ{{7}}

`@script`
rằng list trong Python rất mạnh. Một list có thể chứa bất kỳ kiểu dữ liệu nào và còn có thể chứa nhiều kiểu khác nhau cùng lúc. Ta cũng có thể thay đổi, thêm và xóa phần tử. Điều này rất hữu ích, nhưng vẫn thiếu một tính năng rất quan trọng cho những người làm khoa học dữ liệu như bạn. Khi phân tích dữ liệu, chúng ta thường phải thực hiện các phép tính trên cả một tập hợp giá trị, và phải làm thật nhanh. Và đây là một vấn đề với list.
---

## Hình minh họa

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Hãy xem lại ví dụ về chiều cao của các thành viên trong gia đình. Giả sử bạn cũng hỏi cân nặng của mọi người. Không tế nhị lắm, nhưng không sao, chỉ để học thôi mà. Bạn có hai list: height và weight. Người đầu tiên cao 1,73 mét và nặng 65,4 ki-lô-gam.

Nếu giờ ta muốn tính Chỉ số Khối cơ thể cho từng thành viên, ta cứ nghĩ là phép tính này có thể thực hiện theo từng phần tử.


Nhưng tiếc là Python báo lỗi, vì nó không biết cách tính toán trực tiếp trên list. Ta có thể giải quyết bằng cách duyệt từng phần tử trong list, rồi tính BMI cho từng người, nhưng cách đó rất chậm và mất công viết code.
---

## Giải pháp: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Numeric Python{{1}}

- Phương án thay thế cho list Python: NumPy array{{2}}

- Thực hiện các phép tính trên toàn bộ array{{3}}

- Dễ dàng và nhanh chóng{{4}}

- Quá trình cài đặt{{5}}

	- Trong terminal: `pip3 install numpy`{{6}}

`@script`
Giải pháp dễ dàng hơn nhiều là dùng NumPy, viết tắt của Numeric Python. Đây là một package Python cung cấp một loại list thay thế: NumPy array. NumPy array khá giống với list, nhưng có một tính năng bổ sung: ta có thể thực hiện phép tính trên cả mảng. Cực kỳ dễ và cũng cực nhanh.


Gói NumPy đã được cài sẵn trên máy chủ của DataCamp, nhưng nếu bạn muốn dùng trên máy của mình, hãy mở dòng lệnh và chạy pip3 install numpy.

Tiếp theo,
---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
để dùng NumPy trong phiên làm việc Python, bạn cần import package numpy như thế này.

Chúng ta hãy bắt đầu tạo một Numpy array bằng hàm array của NumPy: đầu vào là một list Python thông thường. Ở đây chúng ta dùng hàm array hai lần để tạo phiên bản NumPy cho các list height và list weight lúc nãy: np_height và np_weight:

Giờ hãy thử tính BMI của mọi người chỉ với một lệnh.

Lần này, mọi thứ hoạt trơn tru: các phép tính được thực hiện theo từng phần tử. BMI của người thứ nhất được tính bằng cách lấy phần tử đầu tiên trong np_weight chia cho bình phương phần tử đầu tiên trong np_height, người thứ hai dùng phần tử thứ hai của height và weight, cứ tiếp tục như vậy.
---

## So sánh

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Hãy so sánh nhanh. Lúc đầu, khi tính với list thông thường như thế này, Python báo lỗi vì không biết cách tính với list như ta yêu cầu. Sau đó, các list này được chuyển thành NumPy array. Các phép toán tương tự giờ lại hoạt động trơn tru: NumPy làm việc với các array như với các giá trị đơn lẻ. Điều này thật tuyệt vời.
---

## Những điều cần lưu ý với Numpy

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- NumPy array: chỉ chứa một kiểu dữ liệu duy nhất{{1}}

`@script`
Tuy vậy, ta vẫn phải chú ý. Thứ nhất, NumPy làm được điều này dễ dàng vì nó giả định một NumPy array chỉ chứa các giá trị có cùng một kiểu. Hoặc là một array chứa các giá trị kiểu float, hoặc là array chứa các giá trị kiểu boolean, vân vân. Như trong ví dụ này, nếu bạn thử tạo một array gồm nhiều kiểu dữ liệu, kết quả là NumPy array sẽ coi tất cả là một kiểu dữ liệu duy nhất là string. Kiểu boolean hay float đều bị chuyển thành string.

Thứ hai, cần chú ý rằng NumPy array đơn giản là một kiểu dữ liệu Python mới, giống như float, string và list mà ta đã học. Điều này có nghĩa là nó có các phương thức riêng, và có thể hoạt động khác với những gì ta mong đợi.
---

## Những điều cần lưu ý với Numpy

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Kiểu dữ liệu khác nhau: cách hoạt động khác nhau!{{3}}

`@script`
Lấy ví dụ list Python này và Numpy array này.

Nếu bạn làm phép tính python_list + python_list, các phần tử sẽ được ghép lại, tạo ra một list có sáu phần tử. Còn nếu làm với các Numpy array, Python sẽ thực hiện phép cộng theo từng phần tử. 

Hãy chú ý khi làm việc với các kiểu dữ liệu Python khác nhau, kết quả có thể rất khác nhau!

Ngoài những điểm này ra,
---

## Trích xuất trong NumPy

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
chúng ta có thể làm việc với NumPy array gần như giống hệt với list Python thông thường. Chẳng hạn, khi muốn lấy phần tử từ array, chúng ta dùng dấu ngoặc vuông. Ví dụ bạn muốn lấy bmi của người thứ hai, tức là ở index 1. Cách này sẽ xử lý được.

Riêng với NumPy, còn có một cách khác để lấy phần tử: đó là lọc array bằng boolean. Giả sử bạn muốn lấy tất cả các giá trị BMI trong array bmi lớn hơn 23. Bước đầu là dùng dấu lớn hơn như thế này:

Kết quả là một NumPy array chứa các giá trị boolean: True nếu bmi tương ứng lớn hơn 23, False nếu nhỏ hơn 23. Tiếp theo, ta đặt array boolean này trong dấu ngoặc vuông để lọc. Chỉ những phần tử trong bmi lớn hơn 23, tức những phần tử có giá trị boolean tương ứng là True, sẽ được chọn. Chỉ có một BMI lớn hơn 23, nên chúng ta nhận được một NumPy array với một giá trị, chính là BMI đó.
 
Sử dụng kết quả của một phép so sánh để lọc dữ liệu là một cách phổ biến để phát hiện những thông tin thú vị từ dữ liệu.
---

## Cùng thực hành nào!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Hãy cùng tìm hiểu tất cả những điều này và các kiến thức cơ bản khác về NumPy trong phần bài tập nào!
