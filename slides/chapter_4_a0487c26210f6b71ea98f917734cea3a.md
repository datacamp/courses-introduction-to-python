---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/de-DE/a0d0c4a9-d149-4309-9384-be7132480792.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Wow, das hast du gut gemacht und jetzt weißt du,

---

## Listen-Zusammenfassung

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Leistungsstark{{1}}

- Sammlung von Werten{{2}}

- Kann verschiedene Typen beinhalten{{3}}

- Ändern, Hinzufügen, Löschen{{4}}

- Notwendig für Data Science{{5}}

  - Mathematische Operationen auf Sammlungen{{6}}

  - Geschwindigkeit{{7}}

`@script`
dass die Python Liste ziemlich mächtig ist. Eine Liste kann alle mögliche Datentypen enthalten und sogar verschiedene Typen in der selben Liste. Du kannst auch Elemente ändern, hinzufügen oder löschen. Das ist super, aber eine Funktion fehlt noch, die für angehende Datenwissenschaftler wie dich sehr wichtig ist. Beim Analysieren von Daten musst du oft Operationen über ganze Wertesammlungen durchführen, und das soll schnell gehen. Bei Listen ist das ein Problem.


---

## Illustration

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Lass uns erneut die Körpergrößen deiner Familie und dir nehmen. Angenommen, du hast auch alle nach ihrem Gewicht gefragt. Das ist zwar nicht besonders höflich, aber für die Wissenschaft tut man alles, oder? Am Ende hast du zwei Listen: Größe und Gewicht. Die erste Person ist „eins-Komma-sieben-drei“ Meter groß und wiegt fünfundsechzig-Komma-vier Kilogramm.

Wenn du jetzt den Body-Mass-Index für jedes Familienmitglied berechnen willst, hoffst du, dass dieser Aufruf funktioniert und die Berechnungen elementweise durchführt.

Leider gibt Python einen Fehler aus, weil es nicht weiß, wie man Berechnungen mit Listen durchführt. Du könntest das lösen, indem du jedes Listenelement nacheinander durchgehst und den BMI für jede Person separat berechnest. Aber diesen Code zu schreiben ist ineffizient und mühsam.


---

## Lösung: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Numerisches Python{{1}}

- Alternative zur Python List: NumPy-Array{{2}}

- Berechnungen über komplette Arrays{{3}}

- Einfach und schnell{{4}}

- Installation{{5}}

	- Im Terminal: `pip3 install numpy`{{6}}

`@script`
Eine viel elegantere Lösung ist die Verwendung von „NumPy“ oder „Numeric Python“. Es handelt sich um ein Python Paket, das unter anderem eine Alternative zur regulären Python Liste bietet: das „NumPy-Array“. Das NumPy-Array ist der Liste sehr ähnlich, hat aber eine zusätzliche Funktion: Du kannst Berechnungen über ganze Arrays durchführen. Es ist echt einfach und geht auch super schnell.

Das NumPy-Paket ist schon auf den Servern von DataCamp installiert. Wenn du es aber auf deinem eigenen Rechner nutzen willst, öffnest du die Befehlszeile und gibst „pip drei install NumPy“ ein.

Als Nächstes,


---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
um NumPy in deiner Python Sitzung zu verwenden, kannst du das NumPy-Paket wie folgt importieren.

Fangen wir mit dem Erstellen eines NumPy-Arrays an. Das machst du mit der Array-Funktion von NumPy: Die Eingabe ist eine normale Python Liste. Ich benutze hier zweimal einen Array, um NumPy-Versionen der vorherigen Listen mit den Körpergrößen und Gewichten zu erstellen: „n-p Unterstrich height“ und „n-p Unterstrich weight“:

Lass uns jetzt erneut versuchen, den BMI von allen mit einem einzigen Aufruf zu berechnen.

Diesmal hat es geklappt: Die Berechnungen wurden elementweise durchgeführt. Der BMI der ersten Person wurde berechnet, indem der erste Wert in „n-p Unterstrich weight“ durch das Quadrat des ersten Werts in „n-p Unterstrich height“ geteilt wurde. Der BMI der zweiten Person wurde mit dem zweiten Wert für Größe und Gewicht berechnet und so weiter.


---

## Vergleich

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Lass uns das kurz vergleichen. Zuerst haben wir versucht, Berechnungen mit normalen Listen durchzuführen, wie hier. Aber das führte zu einem Fehler, weil Python nicht weiß, wie es mit Listen so rechnen soll, wie wir es wollen. Als Nächstes wurden diese normalen Listen in NumPy-Arrays umgewandelt. Die gleichen Vorgänge funktionieren jetzt ohne Probleme: NumPy kann mit Arrays so umgehen, als wären sie einzelne Werte, was ich persönlich großartig finde.


---

## NumPy: Anmerkungen

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- NumPy-Arrays: enthalten nur Daten eines Typs{{1}}

`@script`
Du solltest trotzdem gut aufpassen. Zunächst kann NumPy das alles nur deshalb so einfach ausführen, weil es davon ausgeht, dass dein NumPy-Array nur Werte eines einzigen Typs enthält. Es ist entweder ein Array mit „floats“, ein Array mit booleans und so weiter. Wenn du versuchst, ein Array mit verschiedenen Datentypen zu erstellen, wie zum Beispiel hier, wird das resultierende NumPy-Array nur einen einzigen Typ enthalten. In diesem Fall ist das eine Zeichenfolge, ein string. Der boolean und der float-Wert wurden beide in Zeichenfolgen umgewandelt.

Zweitens solltest du wissen, dass ein NumPy-Array einfach ein weiterer Python Typ ist, wie die bereits behandelten Datentypen „float“, „string“ und „list“. Das bedeutet, dass es eigenen Methoden hat, die sich anders verhalten können, als du es vielleicht erwartest.


---

## NumPy: Anmerkungen

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Unterschiedliche Typen: unterschiedliches Verhalten!{{3}}

`@script`
Nimm zum Beispiel diese Python Liste und dieses NumPy-Array.

Wenn du „Python Unterstrich list plus Python Unterstrich list“ ausführst, werden die Listenelemente zusammengefügt und es entsteht eine Liste mit sechs Elementen. Wenn du das mit den NumPy-Arrays machst, summiert Python die Arrays elementweise.

Passe einfach auf, wenn du mit verschiedenen Python Typen jonglierst, da die Ergebnisse sehr unterschiedlich ausfallen können!

Abgesehen von diesen Feinheiten


---

## NumPy-Teilmengen

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
kannst du mit NumPy-Arrays fast genauso arbeiten wie mit normalen Python Listen. Wenn du Elemente aus deinem Array holen willst, kannst du zum Beispiel eckige Klammern benutzen. Angenommen, du willst den BMI für die zweite Person berechnen, also bei Index „Eins“. Hiermit klappt das.

Speziell für NumPy gibt es noch eine andere Möglichkeit, Listen zu unterteilen: mit einem Array mit Booleschen Werten. Angenommen, du willst alle BMI-Werte im Array „BMI” herausfinden, die über dreiundzwanzig liegen. Ein erster Schritt ist, das Größer-als-Zeichen zu benutzen:

Das Ergebnis ist ein NumPy-Array mit Booleschen Werten: „true“, wenn der entsprechende BMI über dreiundzwanzig liegt. „false“, wenn er darunter liegt. Als Nächstes kannst du dieses boolesche Array in eckigen Klammern verwenden, um Teilmengen zu bilden. Nur die Elemente in „BMI“, die über dreiundzwanzig liegen, also für die der entsprechende boolesche Wert „true“ ist, werden ausgewählt. Es gibt nur einen BMI, der über dreiundzwanzig liegt. Also haben wir letztendlich ein NumPy-Array mit nur einem Wert, nämlich diesem BMI.

Die Verwendung des Ergebnisses eines Vergleichs zur Auswahl deiner Daten ist eine sehr gängige Methode, um überraschende Erkenntnisse zu gewinnen.


---

## Lass uns üben!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Lerne alles darüber und zu weiteren NumPy-Grundlagen in den Übungen.
