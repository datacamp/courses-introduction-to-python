---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/es-ES/092bdb4f-bb77-4f48-b252-557f541031ba.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
“Lo has hecho muy bien! A estas alturas, ya te habrás dado cuenta de que

---

## Resumen de listas

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Potente{{1}}

- Conjunto de valores{{2}}

- Contiene diferentes tipos{{3}}

- Cambia, añade, elimina{{4}}

- Necesidad de ciencia de datos{{5}}

  - Operaciones matemáticas sobre conjuntos{{6}}

  - Velocidad{{7}}

`@script`
la lista de Python es bastante potente. Una lista puede contener cualquier tipo o diferentes tipos al mismo tiempo. También puedes cambiar, añadir y eliminar elementos. Es fantástico, pero falta una función que es muy importante para los aspirantes a científicos de datos como tú. Al analizar datos, normalmente querrás realizar operaciones sobre colecciones de valores completas, y querrás hacerlo rápidamente. Con las listas, esto es un problema.


---

## Ilustración

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Recuperemos tu altura y las de tu familia. Supongamos que también has preguntado el peso de todos. No es muy educado, pero todo por la ciencia, ¿no? Al final, obtienes dos listas: altura y peso. La primera persona mide 1,73 metros y pesa 65,4 kilogramos.

Si ahora quieres calcular el índice de masa corporal de cada miembro de la familia, esperas que esta llamada funcione y realice los cálculos elemento por elemento.

Desafortunadamente, Python arroja un error, porque no sabe cómo hacer cálculos en listas. Podrías resolverlo revisando cada elemento de la lista uno por uno y calculando el IMC de cada persona por separado, pero esto es tremendamente ineficiente y tedioso de escribir.


---

## Solución: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Python numérico{{1}}

- Alternativa a la lista de Python: matriz de NumPy{{2}}

- Cálculos sobre matrices completas{{3}}

- Fácil y rápido{{4}}

- Instalación{{5}}

	- En el terminal: `pip3 install numpy`{{6}}

`@script`
Una solución mucho más elegante es utilizar NumPy o Numeric Python. Es un paquete de Python que, entre otras cosas, proporciona una alternativa a la lista habitual de Python: la matriz de NumPy. La matriz de NumPy es muy similar a la lista, pero tiene una característica adicional: puedes realizar cálculos sobre matrices completas. Es muy fácil y también muy rápido.

El paquete NumPy ya está instalado en los servidores de DataCamp, pero, si deseas trabajar con él en tu propio sistema, ve a la línea de comandos y ejecuta pip3 install numpy.

A continuación,


---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
para utilizar NumPy en la sesión de Python, puedes importar el paquete numpy de la siguiente manera.

Comencemos creando una matriz numpy. Esto se hace con la función de matriz de NumPy: la entrada es una lista de Python normal. Estoy usando una matriz dos veces para crear versiones de NumPy de las listas de altura y peso anteriores: np_height y np_weight:

Intentemos calcular el IMC de todos con una sola llamada.

Esta vez funcionó bien; los cálculos se realizaron elemento por elemento. El IMC de la primera persona se calculó dividiendo el primer elemento de np_weight por el cuadrado del primer elemento de np_height, el IMC de la segunda persona se calculó con los segundos elementos de altura y peso, y así sucesivamente.


---

## Comparación

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Hagamos una comparación rápida aquí. Primero, intentamos hacer cálculos con listas normales, como esta, pero nos dio un error porque Python no sabe cómo hacer cálculos con listas como queremos. A continuación, estas listas regulares se convierten en matrices de NumPy. Las mismas operaciones ahora funcionan sin ningún problema: NumPy sabe trabajar con matrices como si fueran valores únicos, lo cual es bastante impresionante, en mi opinión.


---

## NumPy: observaciones

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- Matrices NumPy: contienen solo un tipo{{1}}

`@script`
Sin embargo, debes seguir prestando atención. En primer lugar, NumPy puede hacer todo esto tan fácilmente porque asume que tu matriz de NumPy solo puede contener valores de un único tipo. Es una matriz de flotantes, una matriz de booleanos, etc. Si intentas crear una matriz con diferentes tipos, como en este ejemplo, la matriz de NumPy resultante contendrá un solo tipo (en este caso, cadena). El booleano y el flotante se convirtieron en cadenas.

En segundo lugar, debes saber que una matriz de NumPy es simplemente un nuevo tipo de Python, como los tipos flotante, cadena y lista anteriores. Esto significa que viene con sus propios métodos, que pueden comportarse de forma diferente a lo que esperas.


---

## NumPy: observaciones

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Diferentes tipos: diferentes comportamientos{{3}}

`@script`
Tomemos como ejemplo esta lista de Python y esta matriz numpy.

Si haces python_list + python_list, los elementos de la lista se pegan juntos y generan una lista con 6 elementos. Por su parte, si haces esto con las matrices numpy, Python hará una suma elemento por elemento de las matrices.

Asegúrate de prestar atención cuando estés usando diferentes tipos de Python, porque los resultados pueden variar mucho.

Aparte de estas sutilezas,


---

## Subconjuntos de NumPy

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
puedes trabajar con matrices de NumPy prácticamente igual que con las listas normales de Python. Cuando quieras obtener elementos de tu matriz, puedes usar corchetes, por ejemplo. Supongamos que quieres obtener el IMC de la segunda persona (es decir, en el índice 1). Esto funcionará.

Específicamente para NumPy, también hay otra forma de hacer subconjuntos de listas: con una matriz de booleanos. Supongamos que quieres obtener todos los valores de IMC en la matriz bmi que sean superiores a 23. Un primer paso es utilizar el signo mayor que, así:

El resultado es una matriz de NumPy que contiene valores booleanos: True si el IMC correspondiente es superior a 23, False si es inferior. A continuación, puedes utilizar esta matriz de booleanos entre corchetes para formar subconjuntos. Solo se seleccionan los elementos de bmi que son superiores a 23 (es decir, aquellos cuyo valor booleano es True). Solo hay un IMC por encima de 23, por lo que obtenemos una matriz de NumPy con un único valor, ese IMC específico.

Utilizar el resultado de una comparación para seleccionar datos es una forma muy habitual de obtener información sorprendente.


---

## ¡Vamos a practicar!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Aprende todo sobre esto y otros conceptos básicos de NumPy en los ejercicios.
