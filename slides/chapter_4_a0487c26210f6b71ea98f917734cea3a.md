---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/it-IT/3f8ba2f9-662c-41cb-9bd0-60541b108476.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Wow, stai andando alla grande e ormai sai

---

## Riepilogo delle liste

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Potente{{1}}

- Raccolta di valori{{2}}

- Tieni diversi tipi{{3}}

- Cambia, aggiungi, elimina{{4}}

- Necessità della scienza dei dati{{5}}

  - Operazioni matematiche sulle collezioni{{6}}

  - Velocità{{7}}

`@script`
che la lista di Python è davvero potente. Una lista può contenere qualsiasi tipo e anche tipi diversi nello stesso momento. Puoi anche cambiare, aggiungere e rimuovere elementi. È fantastico, ma manca una funzione, ed è super importante per chi, come te, vuole diventare data scientist. Quando analizzi i dati, spesso vuoi eseguire operazioni su intere collezioni di valori, e vuoi farlo in fretta. Con le liste, questo è un problema.

---

## Illustrazione

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Riprendiamo le altezze della tua famiglia e la tua. Supponi di aver chiesto anche il peso di tutti. Non è molto educato, ma tutto per la scienza, giusto? Ti ritrovi con due liste, altezza e peso. La prima persona è alta uno virgola settantatre metri e pesa sessantacinque virgola quattro chilogrammi.

Se ora vuoi calcolare il Body Mass Index per ogni membro della famiglia, spereresti che questa chiamata funzioni, facendo i calcoli elemento per elemento.

Purtroppo, Python genera un errore, perché non sa come fare calcoli sulle liste. Potresti risolvere passando ogni elemento della lista uno dopo l’altro e calcolando il BMI per ciascuno separatamente, ma è molto inefficiente e noioso da scrivere.

---

## Soluzione: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Python numerico{{1}}

- Alternativa alla lista Python: Array NumPy{{2}}

- Calcoli su interi array{{3}}

- Facile e veloce{{4}}

- Installazione{{5}}

	- Nel terminale: `pip3 install numpy`{{6}}

`@script`
Una soluzione molto più elegante è usare NumPy, ovvero Numeric Python. È un pacchetto Python che, tra le altre cose, fornisce un’alternativa alla normale lista di Python: l’array di NumPy. L’array di NumPy è abbastanza simile alla lista, ma ha una caratteristica in più: puoi eseguire calcoli su interi array. È davvero semplice, e anche super veloce.

Il pacchetto NumPy è già installato sui server di DataCamp, ma se vuoi usarlo sul tuo sistema, vai alla riga di comando ed esegui pip3 install numpy.

Ora,

---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
per usare davvero NumPy nella tua sessione Python, puoi importare il pacchetto numpy, così.

Cominciamo creando un array di NumPy. Lo fai con la funzione array di NumPy: l’input è una normale lista Python. Qui uso array due volte, per creare le versioni NumPy delle liste height e weight di prima: np_height e np_weight:

Proviamo di nuovo a calcolare il BMI di tutti con un’unica chiamata.

Questa volta ha funzionato: i calcoli sono stati eseguiti elemento per elemento. Il BMI della prima persona è stato calcolato dividendo il primo elemento di np_weight per il quadrato del primo elemento di np_height; il BMI della seconda persona usando il secondo elemento di altezza e peso, e così via.

---

## Confronto

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Facciamo un rapido confronto. Prima, abbiamo provato a fare calcoli con le liste normali, così, ma questo ci ha dato un errore, perché Python non sa come effettuare i calcoli sulle liste nel modo in cui vogliamo. Poi, queste liste normali sono state convertite in array di NumPy. Le stesse operazioni ora funzionano senza problemi: NumPy sa lavorare con gli array come se fossero singoli valori, il che è piuttosto fantastico se me lo chiedi.

---

## NumPy: commenti

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- Array NumPy: contengono solo un tipo{{1}}

`@script`
Dovresti comunque fare attenzione. Prima di tutto, NumPy può fare tutto questo così facilmente perché presuppone che il tuo array di NumPy possa contenere valori di un solo tipo. È o un array di float, o un array di booleani, e così via. Se provi a creare un array con tipi diversi, come in questo esempio, l’array risultante conterrà un solo tipo, stringa in questo caso. Sia il booleano sia il float sono stati convertiti in stringhe.

In secondo luogo, sappi che un array di NumPy è semplicemente un nuovo tipo di Python, come i tipi float, string e list che hai visto prima. Questo significa che ha i propri metodi, che possono comportarsi in modo diverso da quanto ti aspetti.

---

## NumPy: commenti

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Tipi diversi: comportamenti diversi!{{3}}

`@script`
Prendi per esempio questa lista di Python e questo array di NumPy.

Se fai python_list + python_list, gli elementi delle liste vengono concatenati, generando una lista con sei elementi. Se invece lo fai con gli array di NumPy, Python eseguirà una somma elemento per elemento degli array.

Assicurati solo di fare attenzione quando maneggi tipi diversi di Python, perché i risultati possono differire parecchio!

A parte queste sottigliezze,

---

## Sottogruppi NumPy

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
puoi lavorare con gli array di NumPy più o meno come fai con le liste normali di Python. Quando vuoi estrarre elementi dal tuo array, per esempio, puoi usare le parentesi quadre. Supponi di voler ottenere il bmi della seconda persona, quindi all’indice uno. Così funziona.

In particolare per NumPy, c’è anche un altro modo di fare subsetting delle liste: usando un array di booleani. Diciamo che vuoi ottenere tutti i valori di BMI nell’array bmi che sono superiori a ventitre. Un primo passo è usare il segno di maggiore, così:

Il risultato è un array di NumPy contenente booleani: True se il corrispondente bmi è sopra ventitre, False se è sotto. Poi puoi usare questo array di booleani tra parentesi quadre per fare il subsetting. Vengono selezionati solo gli elementi in bmi che sono sopra ventitre, quindi per i quali il valore booleano corrispondente è True. C’è un solo BMI sopra ventitre, quindi otteniamo un array di NumPy con un unico valore, quel BMI specifico.

Usare il risultato di un confronto per selezionare i tuoi dati è un modo molto comune per ottenere intuizioni sorprendenti.

---

## Passiamo alla pratica!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Scopri tutto questo e le altre basi di NumPy negli esercizi!
