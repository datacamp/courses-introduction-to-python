---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/fr-FR/b77ca90f-d2e5-4f4f-955a-e55c312a8e95.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Vous avez bien travaillé et vous savez maintenant

---

## Résumé des listes

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Puissantes{{1}}

- Collectent des valeurs{{2}}

- Contiennent différents types{{3}}

- Modification, ajouts, suppressions{{4}}

- Une nécessité pour la science des données{{5}}

  - Opérations mathématiques sur les collections{{6}}

  - Vitesse{{7}}

`@script`
que la liste Python est très puissante. Une liste peut contenir n'importe quel type et peut contenir différents types en même temps. Vous pouvez également modifier, ajouter et supprimer des éléments. C'est remarquable, mais il manque une fonctionnalité essentielle pour les aspirants data scientists tels que vous. Lors de l'analyse de données, vous souhaiterez souvent effectuer des opérations sur des collections entières de valeurs, et ce rapidement. Avec les listes, cela pose un problème.


---

## Illustration

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Reprenons les tailles de votre famille et de vous-même. Supposons que vous ayez également demandé le poids de tout le monde. Ce n'est pas très courtois, mais tout cela est pour la science, n'est-ce pas ? Vous obtenez deux listes, taille et poids. La première personne mesure 1 mètre 73 et pèse 65 virgule 4 kilos.

Si vous souhaitez maintenant calculer l'indice de masse corporelle de chaque membre de la famille, vous espérez que cet appel fonctionnera et effectuera les calculs élément par élément.

Malheureusement, Python renvoie une erreur, car il ne sait pas comment effectuer des calculs sur des listes. Vous pourriez résoudre ce problème en parcourant chaque élément de la liste un par un et en calculant l'IMC de chaque personne séparément, mais cela serait extrêmement inefficace et fastidieux à écrire.


---

## Solution : NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Python numérique{{1}}

- Alternative à la liste Python : Tableau NumPy{{2}}

- Calculs sur des tableaux entiers{{3}}

- Facile et rapide{{4}}

- Installation{{5}}

	- Dans le terminal : `pip3 install numpy`{{6}}

`@script`
Une solution plus élégante consiste à utiliser NumPy, ou Numeric Python. Il s'agit d'un paquet Python qui, entre autres, fournit une alternative à la liste Python standard : le tableau NumPy. Le tableau NumPy ressemble à la liste, mais il présente une fonctionnalité supplémentaire : il est possible d'effectuer des calculs sur l'ensemble du tableau. C'est très simple et extrêmement rapide.

Le paquet NumPy est déjà installé sur les serveurs de DataCamp, mais si vous souhaitez l'utiliser sur votre propre système, rendez-vous dans la ligne de commande et exécutez pip3 install numpy.

Ensuite,


---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
pour utiliser NumPy dans votre session Python, vous pouvez importer le paquet numpy comme suit.

Commençons par créer un tableau numpy. Vous pouvez le faire avec la fonction array de NumPy : l'entrée est une liste Python normale. J'utilise ici deux fois le tableau pour créer des versions NumPy des listes de tailles et de poids précédentes : N P tiret height et N P tiret weight :

Essayons à nouveau de calculer l'IMC de tout le monde à l'aide d'un seul appel.

Cette fois-ci, cela a bien fonctionné : les calculs ont été effectués élément par élément. L'IMC de la première personne a été calculé en divisant le premier élément de np tiret weight par le carré du premier élément de np tiret height, l'IMC de la deuxième personne a été calculé avec les deuxième et troisième éléments de height et np tiret height, et ainsi de suite.


---

## Comparaison

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Faisons une comparaison rapide ici. Tout d'abord, nous avons essayé d'effectuer des calculs avec des listes classiques, comme ceci, mais cela a généré une erreur, car Python ne sait pas comment effectuer des calculs avec des listes comme nous le souhaitons. Ensuite, ces listes régulières ont été converties en tableaux NumPy. Les mêmes opérations fonctionnent désormais sans problème : NumPy sait comment traiter les tableaux comme s'il s'agissait de valeurs uniques, ce qui est très pratique à mon avis.


---

## NumPy : remarques

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- Tableaux NumPy : ne contiennent qu'un seul type{{1}}

`@script`
Il est toutefois important de rester sur ses gardes. Tout d'abord, NumPy peut effectuer toutes ces opérations avec une telle facilité car il part du principe que votre tableau NumPy ne peut contenir que des valeurs d'un seul type. Il s'agit soit d'un tableau de nombres flottants, soit d'un tableau de booléens, etc. Si vous essayez de créer un tableau avec différents types, comme dans l'exemple suivant, le tableau NumPy obtenu contiendra un seul type, en l'occurrence une chaîne. La valeur booléenne et la valeur flottante ont toutes deux été converties en chaînes.

Deuxièmement, il est important de comprendre qu'un tableau NumPy est simplement un nouveau type Python, comme les types float, string et list précédemment mentionnés. Cela signifie qu'il est fourni avec ses propres méthodes, qui peuvent se comporter différemment de ce à quoi vous vous attendez.


---

## NumPy : remarques

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Différents types : différents comportements !{{3}}

`@script`
Prenons par exemple cette liste Python et ce tableau numpy.

Si vous effectuez python tiret list + python tiret list, les éléments de la liste sont collés ensemble, générant une liste de 6 éléments. Si vous effectuez cette opération avec les tableaux numpy, Python effectuera une somme élément par élément des tableaux.

Faites attention lorsque vous manipulez différents types Python, car les résultats peuvent varier considérablement.

Mis à part ces subtilités,


---

## Sous-ensembles NumPy

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
vous pouvez utiliser les tableaux NumPy de la même manière que les listes Python classiques. Lorsque vous souhaitez extraire des éléments de votre tableau, par exemple, vous pouvez utiliser des crochets. Supposons que vous souhaitiez obtenir l'IMC de la deuxième personne, donc à l'index 1. Ceci fera l'affaire.

Dans le cas particulier de NumPy, il existe également une autre méthode pour extraire une partie d'une liste : utiliser un tableau de booléens. Disons que vous voulez obtenir toutes les valeurs d'IMC supérieures à 23 dans le tableau des IMC. Une première étape consiste à utiliser le signe supérieur à, comme ceci :

Le résultat est un tableau NumPy contenant des valeurs booléennes : Vrai si l'IMC correspondant est supérieur à 23, faux s'il est inférieur. Ensuite, vous pouvez utiliser ce tableau booléen entre crochets pour créer un sous-ensemble. Seuls les éléments d’IMC supérieurs à 23, pour lesquels la valeur booléenne correspondante est Vrai, sont sélectionnés. Il n'y a qu'un seul IMC supérieur à 23, nous obtenons donc un tableau NumPy avec une seule valeur, cet IMC spécifique.

Utiliser le résultat d'une comparaison pour sélectionner vos données est une méthode très courante pour obtenir des informations surprenantes.


---

## Passons à la pratique !

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Découvrez tout cela ainsi que les autres notions fondamentales de NumPy dans les exercices.
