---
title: Insert title here
key: a0487c26210f6b71ea98f917734cea3a
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/pt-BR/9aa1a78f-da61-410d-b79e-24c139d5b214.mp3
---

## NumPy

```yaml
type: TitleSlide
key: 1062fb4e4c
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Uau, você se saiu muito bem e, a esta altura, já sabe

---

## Revisão sobre listas

```yaml
type: FullSlide
key: 819dc4dd09
```

`@part1`
- Muito eficaz{{1}}

- Conjunto de valores{{2}}

- Armazenar diferentes tipos{{3}}

- Alterar, incluir, excluir{{4}}

- Necessidade na ciência de dados{{5}}

  - Operações matemáticas em conjuntos{{6}}

  - Velocidade{{7}}

`@script`
que a lista do Python é bem poderosa. Uma lista pode armazenar qualquer tipo e pode guardar tipos diferentes ao mesmo tempo. Também dá para alterar, incluir e excluir elementos. Isso é incrível, mas está faltando um recurso que é superimportante para quem está começando na área de ciência de dados, como você. Ao analisar dados, muitas vezes queremos fazer operações em conjuntos inteiros de valores, e queremos fazer isso rápido. Com listas, isso é um problema.


---

## Ilustração

```yaml
type: FullSlide
key: c038185807
code_zoom: 64
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
height
```

```out
[1.73, 1.68, 1.71, 1.89, 1.79]
```

```py
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight
```{{1}}

```out
[65.4, 59.2, 63.6, 88.4, 68.7]
```{{1}}

```py
weight / height ** 2
```{{2}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{3}}

`@script`
Vamos voltar à altura das pessoas da família. Imagine que você também perguntou o peso de todo mundo. Não é muito educado, mas tudo pela ciência, não é? O resultado são duas listas, altura e peso. A primeira pessoa tem um metro e setenta e três de altura e pesa sessenta e cinco ponto quatro quilos.

Se você quiser calcular o índice de massa corporal de cada parente, você espera que esta chamada funcione, fazendo os cálculos elemento por elemento.

Infelizmente, o Python mostra um erro, porque não sabe fazer contas com listas. Você poderia resolver isso percorrendo cada elemento da lista, um por um, e calculando o IMC de cada pessoa separadamente, mas seria muito ineficiente e cansativo de escrever.


---

## Solução: NumPy

```yaml
type: FullSlide
key: 7d3d0276cb
```

`@part1`
- Numeric Python{{1}}

- Alternativa à lista do Python: matriz (array) do NumPy{{2}}

- Cálculos em matrizes inteiras{{3}}

- Fácil e rápido{{4}}

- Instalação{{5}}

	- No terminal: `pip3 install numpy`{{6}}

`@script`
Uma solução bem mais elegante é usar o NumPy, ou Numeric Python. É um pacote Python que, entre outras coisas, disponibiliza uma alternativa à lista comum do Python: a matriz ou array do NumPy. A matriz do NumPy é bem parecida com a lista, mas tem mais um recurso: permite fazer cálculos com matrizes inteiras. Além disso, é bem fácil e rápido.

O pacote NumPy já está instalado nos servidores do DataCamp, mas, se quiser trabalhar com ele no seu próprio sistema, vá até a linha de comando e execute pip3 install numpy.

Em seguida,


---

## NumPy

```yaml
type: FullSlide
key: b227a9dc4f
code_zoom: 75
```

`@part1`
```py
import numpy as np
```
```py
np_height = np.array(height)
np_height
```{{1}}

```out
array([1.73, 1.68, 1.71, 1.89, 1.79])
```{{1}}

```py
np_weight = np.array(weight)
np_weight
```{{1}}

```out
array([65.4, 59.2, 63.6, 88.4, 68.7])
```{{1}}

```py
bmi = np_weight / np_height ** 2
bmi
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
para usar o NumPy na sua sessão Python, você pode importar o pacote numpy assim.

Vamos começar criando uma matriz do NumPy. Isso é feito com a função array do NumPy. A entrada é uma lista normal do Python. Estou usando array duas vezes aqui, para criar versões NumPy das listas de altura e peso de antes: np underline height e np underline weight.

Vamos tentar calcular o IMC de todo mundo com uma única chamada de novo.

Desta vez, funcionou bem: os cálculos foram feitos elemento por elemento. O IMC da primeira pessoa foi calculado dividindo o primeiro elemento de np underline weight pelo quadrado do primeiro elemento de np underline height. O IMC da segunda pessoa foi calculado com os segundos elementos de altura e peso, e assim por diante.


---

## Comparação

```yaml
type: FullSlide
key: b0247dd81c
code_zoom: 77
```

`@part1`
```py
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4, 59.2, 63.6, 88.4, 68.7]
weight / height ** 2
```{{1}}

```out
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
```{{1}}

```py
np_height = np.array(height)
np_weight = np.array(weight)
np_weight / np_height ** 2
```{{2}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{2}}

`@script`
Vamos fazer uma comparação rápida aqui. Primeiro, tentamos fazer cálculos com listas normais, desta forma, mas deu erro, porque o Python não sabe fazer contas com listas do jeito que queremos. Depois, essas listas normais foram transformadas em matrizes do NumPy. Agora, as mesmas operações funcionam sem nenhum problema: o NumPy sabe trabalhar com matrizes como se fossem valores únicos, o que é bem legal, na minha opinião.


---

## NumPy: comentários

```yaml
type: FullSlide
key: f9882b091b
code_zoom: 90
```

`@part1`
```py
np.array([1.0, "is", True])
```{{1}}

```out
array(['1.0', 'is', 'True'], dtype='<U32')
```{{1}}

- Matrizes do NumPy: contêm um único tipo{{1}}

`@script`
Ainda assim, é bom ficar de olho. Primeiro, o NumPy consegue fazer tudo isso tão fácil porque pressupõe que sua matriz do NumPy pode ter apenas valores de um único tipo. É uma matriz de floats, ou uma matriz de booleanos e assim por diante. Se você tentar criar uma matriz com tipos diferentes, como neste exemplo, a matriz resultante do NumPy vai ter um único tipo, neste caso, string. Tanto os booleanos quanto os floats foram convertidos em strings.

Segundo, você deve saber que uma matriz do NumPy é simplesmente um novo tipo em Python, como os tipos float, string e list de antes. Isso quer dizer que ela tem seus próprios métodos, que podem funcionar de um jeito diferente do esperado.


---

## NumPy: comentários

```yaml
type: FullSlide
key: 4da6149ced
code_zoom: 80
```

`@part1`
```py
python_list = [1, 2, 3]
numpy_array = np.array([1, 2, 3])
```

```py
python_list + python_list
```{{1}}

```out
[1, 2, 3, 1, 2, 3]
```{{1}}

```py
numpy_array + numpy_array
```{{2}}

```out
array([2, 4, 6])
```{{2}}

- Tipos diferentes: comportamentos diferentes!{{3}}

`@script`
Veja esta lista do Python e esta matriz do NumPy, por exemplo.

Se você fizer python underline list mais python underline list, os elementos da lista vão ser combinados, criando uma lista com seis elementos. Por outro lado, se você fizer isso com as matrizes do NumPy, o Python vai somar os elementos das matrizes.

Lembre-se de prestar atenção quando estiver lidando com diferentes tipos em Python, porque os resultados podem variar bastante!

Com exceção desses detalhes,


---

## Divisão em subconjuntos no NumPy

```yaml
type: FullSlide
key: c1f3774f83
code_zoom: 71
```

`@part1`
```py
bmi
```{{1}}

```out
array([21.85171573, 20.97505669, 21.75028214, 24.7473475 , 21.44127836])
```{{1}}

```py
bmi[1]
```{{2}}

```out
20.975
```{{2}}

```py
bmi > 23
```{{3}}

```out
array([False, False, False,  True, False])
```{{3}}

```py
bmi[bmi > 23]
```{{4}}

```out
array([24.7473475])
```{{4}}

`@script`
você pode trabalhar com matrizes do NumPy praticamente da mesma forma que com listas comuns do Python. Quando quiser pegar elementos da matriz, por exemplo, pode usar colchetes. Suponha que você queira saber o IMC da segunda pessoa, ou seja, no índice um. Isto resolve o problema.

O NumPy, especificamente, também tem outra maneira de fazer a subdivisão de listas: usando uma matriz de booleanos. Suponha que você queira pegar todos os valores de IMC acima de vinte e três na matriz bmi. O primeiro passo é usar o sinal maior que, deste jeito.

O resultado é uma matriz do NumPy com valores booleanos: verdadeiro se o IMC correspondente estiver acima de vinte e três, falso se estiver abaixo. Em seguida, dá para usar essa matriz de booleanos entre colchetes para dividir em subconjuntos. Só os elementos de bmi que estão acima de vinte e três, ou seja, aqueles cujo valor booleano é verdadeiro, são selecionados. Só tem um IMC acima de vinte e três, então acabamos com uma matriz do NumPy com um único valor, este IMC específico.

Usar o resultado de uma comparação para selecionar dados é uma maneira muito comum de obter insights surpreendentes.


---

## Vamos praticar!

```yaml
type: FinalSlide
key: 1138fd29b8
```

`@script`
Aprenda tudo sobre isso e outros conceitos básicos do NumPy nos exercícios!
