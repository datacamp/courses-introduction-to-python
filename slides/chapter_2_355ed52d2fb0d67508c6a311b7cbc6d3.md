---
title: Insert title here
key: 355ed52d2fb0d67508c6a311b7cbc6d3
video_link:
  mp3: >-
    https://videos.datacamp.com/mp3/translations/course_735/pt-BR/6698e634-313c-470b-9513-8e6d5b3519d7.mp3
---

## Manipulação de listas

```yaml
type: TitleSlide
key: 6484e4d1f6
```

`@lower_third`
name: Hugo Bowne-Anderson
title: Data Scientist at DataCamp

`@script`
Uau, você está indo muito bem. Depois da criação e divisão em subconjuntos, a última peça do quebra-cabeça das listas em Python é


---

## Manipulação de listas

```yaml
type: FullSlide
key: 5b83249ee9
```

`@part1`
- Alterar elementos da lista{{1}}

- Incluir elementos na lista{{2}}

- Excluir elementos da lista{{3}}

`@script`
a manipulação, maneiras de alterar elementos da lista, como incluir e excluir elementos.


---

## Como alterar elementos da lista

```yaml
type: FullSlide
key: c1d58a3c4c
code_zoom: 64
```

`@part1`
```py
fam = ["liz", 1.73, "emma", 1.68, "mom", 1.71, "dad", 1.89]
fam
```

```out
['liz', 1.73, 'emma', 1.68, 'mom', 1.71, 'dad', 1.89]
```

```py
fam[7] = 1.86
fam
```{{1}}

```out
['liz', 1.73, 'emma', 1.68, 'mom', 1.71, 'dad', 1.86]
```{{1}}

```py
fam[0:2] = ["lisa", 1.74]
fam
```{{2}}

```out
['lisa', 1.74, 'emma', 1.68, 'mom', 1.71, 'dad', 1.86]
```{{2}}

`@script`
É bem fácil mudar elementos da lista. Usamos os mesmos colchetes que utilizamos para subdividir listas e, em seguida, atribuímos novos elementos usando o sinal de igual. Imagine que, depois de dar uma olhada na foto de família, você percebe que a altura do seu pai está desatualizada, já que ele está encolhendo com a idade. Em vez de um metro e oitenta e nove, deveria ser um metro e oitenta e seis. Para mudar esse elemento da lista, que está no índice sete, dá para usar esta linha de código.

Agora, se você der uma olhada em fam, vai ver que o valor foi atualizado.

Você pode até mudar uma fatia inteira da lista de uma só vez. Para mudar os elementos “liz” e um ponto setenta e três, você acessa os dois primeiros elementos com zero, dois pontos, dois e, em seguida, atribui a eles uma nova lista.

Você ainda lembra que o operador mais era diferente para strings e inteiros?


---

## Como incluir e excluir elementos

```yaml
type: FullSlide
key: a66d56cb46
code_zoom: 74
```

`@part1`
```py
fam + ["me", 1.79]
```{{1}}

```out
['lisa', 1.74,'emma', 1.68, 'mom', 1.71, 'dad', 1.86, 'me', 1.79]
```{{1}}

```py
fam_ext = fam + ["me", 1.79]
```{{2}}
```py
del fam[2]
```{{3}}
```py
fam
```{{4}}

```out
['lisa', 1.74, 1.68, 'mom', 1.71, 'dad', 1.86]
```{{4}}

`@script`
Bem, com listas também é diferente. Quando usamos o sinal de mais com duas listas, o Python simplesmente combina o conteúdo delas em uma única lista. Suponha que você queira colocar seu nome e altura na lista de altura da família. Isto resolve o problema.

É claro que também podemos armazenar essa nova lista em uma variável, como fam_ext.

Por fim, apagar elementos de uma lista também é bem simples. Você vai precisar usar del. Observe esta linha, que apaga da lista o elemento com índice dois, ou seja, “emma”.

Agora, se você der uma olhada em fam, vai ver que a string “emma” sumiu. Como você excluiu um índice, todos os elementos que vieram depois de “emma” se moveram uma posição no índice. Se você executar a mesma linha de novo, mais uma vez vai remover o elemento no índice dois, que é a altura de Emma, agora um metro e sessenta e oito.

Entender como realmente funcionam as listas em Python


---

## O que acontece por trás (1)

```yaml
type: TwoColumns
key: ef5370967a
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```{{1}}

`@part2`
![ch_2_3_slides.024.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/e91761036b6647fa635fe8493b4ff3379587f5d5/ch_2_3_slides.024.png = 70){{2}}

`@script`
é bem importante agora. O que realmente acontece quando criamos uma nova lista, x, assim?

Em termos simples, armazenamos uma lista na memória do computador, guardando o “endereço” dessa lista,


---

## O que acontece por trás (1)

```yaml
type: TwoColumns
key: 4d48163f25
disable_transition: true
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```
```py
y = x
```{{1}}
```py
y[1] = "z"
y
```{{2}}

```out
['a', 'z', 'c']
```{{2}}

```py
x
```{{3}}

```out
['a', 'z', 'c']
```{{3}}

`@part2`
![ch_2_3_slides.025.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/03d95d40b2e0d631ea89f07cadf12e66babd3693/ch_2_3_slides.025.png = 70)

`@script`
onde a lista fica na memória do computador, em x. Isso quer dizer que x não contém todos os elementos da lista, mas sim uma referência para a lista. Nas operações básicas, a diferença não é tão importante, mas passa a ser quando começamos a copiar listas. Vou explicar melhor com um exemplo.

Vamos armazenar a lista x como uma nova variável y. Basta usar o sinal de igual.

Agora vamos trocar o elemento com índice igual a um na lista y, assim.

O engraçado é que, se você olhar x de novo, o segundo elemento também mudou.

Isso porque, quando você copiou x para y com o sinal de igual,


---

## O que acontece por trás (1)

```yaml
type: TwoColumns
key: 4a5827f664
disable_transition: true
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```
```py
y = x
```
```py
y[1] = "z"
y
```

```out
['a', 'z', 'c']
```

```py
x
```

```out
['a', 'z', 'c']
```

`@part2`
![ch_2_3_slides.030.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/cee01ad8680d8cd824bab998aed4c5e5f74521bb/ch_2_3_slides.030.png = 70)

`@script`
copiou a referência à lista, não os valores em si.

---

## O que acontece por trás (1)

```yaml
type: TwoColumns
key: ef3476e2fc
disable_transition: true
```

`@part1`
```py
x = ["a", "b", "c"]
```
```py
y = x
```
```py
y[1] = "z"
y
```

```out
['a', 'z', 'c']
```

```py
x
```

```out
['a', 'z', 'c']
```

`@part2`
![ch_2_3_slides.031.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/fff4d255ec69a9a6e4d64394bdb92464390498c4/ch_2_3_slides.031.png = 70)

`@script`
Quando você atualiza um elemento da lista, está alterando a mesma lista na memória do computador. Tanto x quanto y apontam para essa lista, então a atualização fica visível nas duas variáveis.

Para criar uma lista y que aponte para uma nova lista na memória com os mesmos valores,


---

## O que acontece por trás (2)

```yaml
type: TwoColumns
key: 05f37e881d
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```

`@part2`
![ch_2_3_slides.033.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/97dc873ce995a7fb3cf83305c56a6a9b4f23de51/ch_2_3_slides.033.png)

`@script`
você precisa usar outra opção sem ser o sinal de igual. Você pode usar a função list,


---

## O que acontece por trás (2)

```yaml
type: TwoColumns
key: 678dfa958a
disable_transition: true
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```
```py
y = list(x)
y = x[:]
```

`@part2`
![ch_2_3_slides.034.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/ec9a50129117c16795d74c53b070c34c0015f6d1/ch_2_3_slides.034.png)

`@script`
assim, ou usar o fatiamento para selecionar formalmente todos os elementos da lista.

Agora, se você

---

## O que acontece por trás (2)

```yaml
type: TwoColumns
key: d211be5714
disable_transition: true
code_zoom: 100
```

`@part1`
```py
x = ["a", "b", "c"]
```
```py
y = list(x)
y = x[:]
```
```py
y[1] = "z"
x
```

```out
['a', 'b', 'c']
```

`@part2`
![ch_2_3_slides.036.png](https://assets.datacamp.com/img/translations/pt-BR/production/repositories/288/datasets/3f6b4d36a70007385ff752d07fa842a1e3a7f878/ch_2_3_slides.036.png)

`@script`
mudar a lista que y referencia, x não será afetado.

Se isso parece muito complicado, não se preocupe.

---

## Vamos praticar!

```yaml
type: FinalSlide
key: 934a5be348
```

`@script`
Os exercícios vão ajudar a entender como trabalhar com listas e como elas funcionam. Tenho certeza de que você vai se sair muito bem!
